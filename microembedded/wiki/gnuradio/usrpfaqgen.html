<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage"><!-- InstanceBegin template="/Templates/gnuradio.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<link rel="shortcut icon" type="image/x-icon" href="../images/sites-16.ico" />
<!--声明当前的页面的编码集-->
<meta charset="utf-8"/>
<meta name="title" content="GNU Radio 中文社区">
<meta itemprop="name" content="GNU Radio 中文社区">
<meta property="og:title" content="GNU Radio 中文社区">
<meta name="description" content="微嵌 - GNU Radio 中文维客 由 微嵌软件技术(北京)有限责任公司维护。GNU Radio 是免费的软件开发工具套件。它提供信号运行和处理模块，用它可以在易制作的低成本的射频（RF）硬件（比如：USRP 和USRP2）和通用微处理器上实现软件定义无线电。这套套件广泛用于业余爱好者，学术机构和商业机构用来研究和构建无线通信系统。">
<meta itemprop="description" content="微嵌 - GNU Radio 中文维客 由 微嵌软件技术(北京)有限责任公司维护。GNU Radio 是免费的软件开发工具套件。它提供信号运行和处理模块，用它可以在易制作的低成本的射频（RF）硬件（比如：USRP 和USRP2）和通用微处理器上实现软件定义无线电。这套套件广泛用于业余爱好者，学术机构和商业机构用来研究和构建无线通信系统。">
<meta id="meta-tag-description" property="og:description" content="微嵌 - GNU Radio 中文维客 由 微嵌软件技术(北京)有限责任公司维护。GNU Radio 是免费的软件开发工具套件。它提供信号运行和处理模块，用它可以在易制作的低成本的射频（RF）硬件（比如：USRP 和USRP2）和通用微处理器上实现软件定义无线电。这套套件广泛用于业余爱好者，学术机构和商业机构用来研究和构建无线通信系统。">
<!-- InstanceBeginEditable name="doctitle" -->
<title>GNU Radio 中文社区</title>
<!-- InstanceEndEditable -->
<meta name="renderer" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
<link rel="stylesheet" type="text/css" href="../css/css.css">
<link rel="stylesheet" type="text/css" href="../css/overlay.css">
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" zh_CN">
<div id="sites-chrome-everything-scrollbar">
    <div id="sites-chrome-everything" class="">
        <div id="sites-chrome-page-wrapper" style="direction: ltr">
            <div id="sites-chrome-page-wrapper-inside">
                <div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="height:auto;">
                    <table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="height:auto;">
                        <tbody>
                            <tr class="sites-header-primary-row" id="sites-chrome-userheader">
                                <td id="sites-header-title" class="sites-chrome-header-valign-bottom"><div class="sites-header-cell-buffer-wrapper">
                                        <h2><a href="http://gnuradio.microembedded.com/" id="sites-chrome-userheader-logo"> <img id="logo-img-id" src="../images/logo.jpg" alt="GNU Radio 中文社区" class="sites-logo sites-chrome-header-valign-bottom "></a></h2>
                                    </div></td>
                            </tr>
                            <tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
                                <td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div id="sites-chrome-main-wrapper">
                    <div id="sites-chrome-main-wrapper-inside">
                    <!-- InstanceBeginEditable name="head" -->
                    <table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tbody><tr>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="display: none;">
</div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="display: none;" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">UsrpFAQGen</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<table xmlns="http://www.w3.org/1999/xhtml" cellspacing="0" class="sites-layout-name-one-column sites-layout-hbox"><tbody><tr><td class="sites-layout-tile sites-tile-name-content-1"><div dir="ltr"><div style="text-align:right"></div><h2><a name="TOC-USRP-"></a><font size="3">USRP 一般常见问题</font></h2><p style="text-align:right"><b>[<a href="usrpfaqintro.html"> &lt;&lt; USRP 简介</a> | <a href="usrpfaq.html">^ USRP FAQ 首页 ^</a> | <a href="usrpfaqfpgaverilog.html">FPGA/Verilog &gt;&gt;</a> ]</b></p><h3><a name="TOC-LED"></a><font size="2"><span style="font-family:simsun,serif">闪烁的 LED </span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">USRP一上电，USB控制器右面的 LED 指示灯以每秒三次的频率闪烁。只要 USRP 的应用启动，灯的闪烁频率降至每秒一次。是什么在控制 LED 指示灯闪烁？ </span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">LED 指示灯是由母板上的 FX2 USB 控制器控制。当 USRP 刚一上电，一段特别小的程序从 256 byte 的 EEPROM 中载入。这段代码把 AD9862 设置成低功耗状态同时快速循环使得 LED 灯每秒闪烁三次。参见如下代码：</span></font><br style="font-family:simsun,serif"></div><div style="margin-left:80px"><font size="2"><span style="font-family:simsun,serif"> <a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/eeprom_init.c" target="_blank">gnuradio/trunk/usrp/firmware/src/usrp2/eeprom_init.c </a></span></font><br style="font-family:simsun,serif"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/eeprom_init.c" target="_blank"><font size="2"><span style="font-family:simsun,serif">usrp/firmware/src/usrp2/eeprom_init.c</span></font></a><br><br style="font-family:simsun,serif"></div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">一旦“常规”固件载入，定时器中断服务例程 （isr_tick）使得闪烁变慢，参见如下代码： </span></font><br style="font-family:simsun,serif"></div><div style="margin-left:80px"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/usrp_main.c" target="_blank"><font size="2"><span style="font-family:simsun,serif">gnuradio/trunk/usrp/firmware/src/usrp2/usrp_main.c </span></font></a><br style="font-family:simsun,serif"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/usrp_main.c" target="_blank"><font size="2"><span style="font-family:simsun,serif">usrp/firmware/src/usrp2/usrp_main.c</span></font></a><br></div><b><font size="2"><span style="font-family:simsun,serif"><br></span></font></b><h3><a name="TOC-O-U-u-a-"></a><b><font size="2"><span style="font-family:simsun,serif">输 出 "O" "U" "u" "a" 的意义</span></font></b></h3><div><ul><li><b><font size="2"><span style="font-family:simsun,serif">当运行 gnu radio 程序时，会有时看见 "O" "U" "u" "a" 字符出现在屏幕上。这一般当数据从 USRP 到 PC 机数据传输停止或什么事情发生时会出现。很好奇它的涵义？速度快的 PC 能减少这些错误吗？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">    "u" = USRP </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    "a" = audio (声卡) </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    "O" = overrun （PC 无法同步地接受来自 USRP 或 声卡的数据 - </span></font>PC not keeping up with received data from usrp or audio card）<br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    "U" = underrun（PC 无法快速的提供数据 - </span></font>PC not providing data quickly enough）<br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    aUaU == audio underrun&nbsp; （PC 无法快速地给“漏”-&nbsp; 声卡提供数据 - </span></font>not enough samples ready to send to sound card sink<font size="2"><span style="font-family:simsun,serif">）</span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    uUuU == USRP underrun （PC 无法快速地给</span></font><font size="2"><span style="font-family:simsun,serif">“漏”- </span></font><font size="2"><span style="font-family:simsun,serif">USRP提供数据 - </span></font>not enough sample ready to send to USRP sink<font size="2"><span style="font-family:simsun,serif">）</span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    uOuO == USRP overrun （USRP 采样掉链源于它没有及时准备到位&nbsp; - </span></font>USRP samples dropped because they weren't read in time）<br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">是的，速度快的计算机可以避免问题。当然，前提是没有让 USB 干它负荷不起的事情。理想的情况是 USB 负荷 32MB/s。建议尽量避免使用 Intel 的 Celeron 或 “缓存能力不强”的部件。</span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-uO---Does-the-number-of-uO-s-correspond-to-the-number-of-samples-dropped-"></a><font size="2"><span style="font-family:simsun,serif">是否‘uO' 出现的频率同采样丢失的频率相同？-</span> Does
 the number of 'uO's correspond to the number of samples dropped?</font></h3> </div><div><ul><li><b><font size="2"><span style="font-family:simsun,serif">是否 ‘uO' 出现的频率同采样丢失的频率相同？</span></font></b></li></ul><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">不是的。Overrun 的检测显示是由一个大概 10Hz 频率的循环来控制的。 如果以数据流的频率（显示），将无法看见 uO 字符。 </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-USRP-1"></a><font size="2"><span style="font-family:simsun,serif">USRP 的启动过程如何</span></font></h3></div><div><ul><li><b><font size="2"><span style="font-family:simsun,serif">一旦上电和 插入 USB 连接器，会发生什么事情？ 启动的顺序如何？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">USRP 自身不带任何性质的 ROM 固件，（EEPROM 内）仅仅几个字节的数据用来标识设备编号（VID），产品编号（PID）和版本修正号。当 USRP 第一次插入 PC 的 USB 连接器中，宿主机（上的 gnu radio）程序库便发现了一个没有被配置的 USRP。</span></font><font size="2"><span style="font-family:simsun,serif">通过设备编号（VID），产品编号（PID）和版本修正号，</span></font><font size="2"><span style="font-family:simsun,serif">程序库</span></font><font size="2"><span style="font-family:simsun,serif">便可确认 USRP 是否被配置。此后它要做的第一件事就是下载描述 USB 外围控制器的（固件 -firmware）代码到母板上的 8051 器件中。当下载的代码一旦运行，USRP 便模拟常规 USB 的断开和重新连接的过程。</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">一旦重新连接，计算机便检测到不同的设备编号（VID），产品编号（PID）和版本修正号。正在运行的</span></font><font size="2"><span style="font-family:simsun,serif">（固件 -firmware）代码</span></font><font size="2"><span style="font-family:simsun,serif">同时定义了 USB 的端点（</span></font>endpoints<font size="2"><span style="font-family:simsun,serif">），接口（</span></font>interfaces<font size="2"><span style="font-family:simsun,serif">）和命令句柄（</span></font>command handlers<font size="2"><span style="font-family:simsun,serif">）。此时一条应当被 USB 控制器解释的命令便是下载 FPGA - 也就是说程序库识别到通过</span></font><font size="2"><span style="font-family:simsun,serif">重新连接</span></font><font size="2"><span style="font-family:simsun,serif">被配置成一个新设备</span></font><font size="2"><span style="font-family:simsun,serif">的</span></font><font size="2"><span style="font-family:simsun,serif"> USRP，</span></font><font size="2"><span style="font-family:simsun,serif">它便进入启动的另一个阶段，下载</span></font><font size="2"><span style="font-family:simsun,serif">配置</span></font><font size="2"><span style="font-family:simsun,serif"> FPGA 的数据流。</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">一旦</span></font><font size="2"><span style="font-family:simsun,serif">（固件 -firmware）代码</span></font><font size="2"><span style="font-family:simsun,serif">被下载到FX2，它便配置其内部寄存器并重新启动它，同时将呈现出，通过 FX 断开再相连而标识出的，同USB相连的设备的“最终”的设备编号（VID），产品编号（PID）。</span></font>
</div>
</div><div><h3><a name="TOC--"></a><font size="2"><span style="font-family:simsun,serif">使用什么工具</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">在 FPGA 编程时你使用什么工具？在布局 USRP 母板时你使用什么工具？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">编写 FPGA 程序使用 Verilog，编译使用 Altera 公司的 Quartus 。母板用 PADS 布局（PCB），但不提供布局（PCB）文件。原理图使用 gEDA。 </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-5V-USRP"></a><font size="2"><span style="font-family:simsun,serif">5V 足以驱动 USRP </span></font></h3> </div><div><ul><li><b><font size="2"><span style="font-family:simsun,serif">可以用 5V 输出的 DC-DC 电源转换器驱动 USRP 吗？</span></font></b></li></ul><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">USRP 母板可以由 5V 电源驱动。但是大多数的子板需从 6V 调整到 5V,也就是说需要的正确电压是 5.5 到 5.75 V。只有</span></font><font size="2"><span style="font-family:simsun,serif">只有</span></font><font size="2"><span style="font-family:simsun,serif"> BasixRX 和 BasicTX 不需 6V。</span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-USRP-2"></a><font size="2"><span style="font-family:simsun,serif">USRP 的最大供电电压</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">USRP 的最大直流供电电压是多少？ 可以用 13.8V 吗？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">不，不可以。USRP 使用线性调节器，所以加载 13.8V 结果导致负荷额外的10瓦能量。而且，母板上的很多电容器的电压范围是 6V, 10V 将毁坏它们。</span></font><br style="font-family:simsun,serif"></div> <h3><a name="TOC-USRP-3"></a><font size="2"><span style="font-family:simsun,serif">USRP 母板保险丝</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">USRP 母板的保险丝的规格？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">保险丝的尺 寸是 0603。规格 3Amps。 </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-FPGA-"></a><font size="2"><span style="font-family:simsun,serif">FPGA 时钟频率</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">我想 EP1C12Q240C8 FPGA 运行频率远远超过 64MHz。</span></font></b></li></ul><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">当 Fmax 工作大于 64MHz 的频率时，FPGA 是足以胜任的（或者，我这么认为）. </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC--1"></a><font size="2"><span style="font-family:simsun,serif">控制及协议 </span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">控制信号是如何工作的？ 协议如何？当我写下如下代码时，它是如何被解释和传输到 FPGA 的 master_control 模块的。 </span></font></b></li></ul><div style="margin-left:80px"><font size="2"><span style="font-family:simsun,serif">    src = usrp.source_c (0, decim)</span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    src.set_rx_freq (0, IF_freq)</span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    src.set_pga(0,20)</span></font><br style="font-family:simsun,serif"></div><font size="2"><br style="font-family:simsun,serif"></font></div><div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">请参阅代码 usrp_standard.{h,cc}, usrp_basic.{h,cc}, and usrp_prims.{h,cc}。它们都作为控制信息通过 USB 到端点 0（</span></font>endpoint 0<font size="2"><span style="font-family:simsun,serif">）。这些控制信息在 FX2 被解释并被执行。一般而言，通过 I2C 和 SPI 总线实现其意图。</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">通过 SPI 总线读写 FPGA 寄存器，AD9862 寄存器和子板。通过 I2C 配置 EEPROM 和子板。详细信息参阅 USRP 原理图。代码 </span><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_spi_defs.h" target="_blank">usrp/firmware/include/usrp_spi_defs.h</a><span style="font-family:simsun,serif"> 包含 SPI 总线的定义。代码 </span><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_i2c_addr.h" target="_blank">usrp/firmware/include/usrp_i2c_addr.h</a><span style="font-family:simsun,serif"> 包含标准的 I2C 的地址的定义。还有一些子板用另外的子板插入时所赋予的插槽的功能。</span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC--2"></a><font size="2"><span style="font-family:simsun,serif">缓存空间</span></font></h3> <ul><li><b><font size="2"><span style="font-family:simsun,serif">USRP 的缓存空间多大？</span></font></b></li></ul></div><div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">USRP 在以下三个地方具有缓存：</span></font><br style="font-family:simsun,serif"></div><div style="margin-left:80px"><font size="2"><span style="font-family:simsun,serif">    在计算机： 目前 8MB 用于 TX, 8MB 用于 Rx. ( #如果有错的话# )</span></font><br><font size="2"><span style="font-family:simsun,serif">    在 Cypress FX2 USB 的外设： 2KB TX 和 2KB Rx. ( #FIXME# )</span></font><br><font size="2"><span style="font-family:simsun,serif">    在 FPGA: 4KB TX 和 4KB RX.</span></font></div> </div><div><h3><a name="TOC-RX-"></a><font size="2"><span style="font-family:simsun,serif">缓存两路 RX 链路</span></font></h3><ul><li><p><b><font size="2"><span style="font-family:simsun,serif">当有两路 RX 链路时，rx_buffer 是如何用来分别处理两个 RX 链路的？ - </span></font></b><b>When I have two RX Channels, then how exactly is the rx_buffer 
used to store and keep the data coming from 2 RX paths separated?</b></p></li></ul> </div><div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">两个不同的链路交替的先进先出 FIFO。其数据如下顺序：</span></font></div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">CH1-I </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">CH1-Q </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">CH2-I </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">CH2-Q </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">诸如此类...</span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-1TX-1RX"></a><font size="2"><span style="font-family:simsun,serif">配置 1TX, 1RX</span></font></h3><ul><li><h3><a name="TOC-RX-TX-source:gnuradio-trunk-usrp-fpga-toplevel-usrp_std-usrp_std.vh-usrp_std.vh-2rx-1tx-4rx.-"></a><font size="2"><span style="font-family:simsun,serif">只想配置一个</span><font size="2"><span style="font-family:simsun,serif">带半带滤波</span></font>的 <span style="font-family:simsun,serif">RX 链路和一个 TX。在</span><b> [source:gnuradio/trunk/usrp/fpga/toplevel/usrp_std/usrp_std.vh 
usrp_std.vh] 里只有 2rx, 1tx 或 4rx. </b></font><font size="2"><span style="font-family:simsun,serif">该如何办? </span></font></h3></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">编辑 config.vh，</span></font><font size="2"><span style="font-family:simsun,serif">去掉 // ，</span></font><font size="2"><span style="font-family:simsun,serif">开启下行命令：</span></font></div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">//`include "../include/common_config_1rxhb_1tx.vh"</span></font><br style="font-family:simsun,serif"></div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">用 // 关闭后面的命令 : <br>`include "../include/common_config_2rxhb_2tx.vh"</span></font><br><br style="font-family:simsun,serif"></div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">通过 // 的使用，这样一来只有一个 RX 链路带半带滤波和一个 TX。 </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-Python-"></a><font size="2"><span style="font-family:simsun,serif">Python 中的可控参数</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">用 Python 可以控制 FPGA 和 AD/DA 转换器的有：</span></font><font size="2"><span style="font-family:simsun,serif">增益和抽取速率。AD/DA 
的位/采样（bits/sample）可由 PYTHON 控制吗？PYTHON 还能干什么？</span></font></b></li></ul><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">ADCs 总是用 12 位 
采样。</span></font><font size="2"><span style="font-family:simsun,serif">ADCs 是 14 位。USRP 内的数据处理是16位的。用 Python 你可以通过 USB 把它切换到 8 位。这可以让你加倍你的采样速率（16MSPS)。</span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-I2C-EEPROM"></a><font size="2"><span style="font-family:simsun,serif">控 制 I2C, 存储器映射，读EEPROM </span></font></h3> </div><div><ul><li><b><font size="2"><span style="font-family:simsun,serif">正在熟悉的应用程序 </span></font></b><b>usrper</b><b><font size="2"><span style="font-family:simsun,serif">。 可以读写 9862芯片但对  i2c_read 的</span></font></b><b><font size="2"><span style="font-family:simsun,serif">所有尝试都</span></font></b><b><font size="2"><span style="font-family:simsun,serif">失败了？ 存储器的映射如何?</span></font></b></li></ul><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">PYTHON 可以干这些事情，出错大概用错了 I2C 的地址。 参看： </span></font>[source:<a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_i2c_addr.h" target="_blank">gnuradio/trunk/usrp/firmware/include/usrp_i2c_addr.h</a>&nbsp; 
<a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_i2c_addr.h" target="_blank">usrp/firmware/include/usrp_i2c_addr.h</a>].<font size="2"><span style="font-family:simsun,serif"> 可与核实其地址。</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif"><b>但请注意</b>，如仅想去读 EEPROM 的内容，最好请使用 read_eeprom。</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">      python 的有关代码如下：</span></font><br><br style="font-family:simsun,serif"><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">    u = usrp.sink_c(0) &nbsp; &nbsp; # or u = usrp.source_c(0) </span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    # returns a string</span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    s = u.read_eeprom(i2c_addr, eeprom_offset, nbytes) </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    print s </span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    # returns a string </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    s = u.read_i2c(i2c_addr, nbytes) </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    print s</span></font><br style="font-family:simsun,serif"></div></div><h3><a name="TOC--3"></a><font size="2"><span style="font-family:simsun,serif">收/发 开关时延</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">如何控制自动收/发开关时延？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">通过 Python，在使用外部收/发开关时可以手动的调整自动收/发开关的时间偏置，以便更好的调整发射数据。</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">在早期的代码中，自动收/发功的能是基于 FPGA 的发送 FIFO 寄存器中是否有数据来切换的。然而这没有考虑到 FPGA 插值器和 AD9862 的DAC </span></font><font size="2"><span style="font-family:simsun,serif">上变</span></font><font size="2"><span style="font-family:simsun,serif">频的管道时滞（</span></font>pipeline delay<font size="2"><span style="font-family:simsun,serif">）问题。尽管实际情况取决于发射端的插值速率，在发送数据被全部传送完之前这有可能导致 ATR (自动收/发功能切换)信号或早 25 us，或迟 35us。如果使用用高速外部 Rx/Tx 切换的话，可能会导致发射数据流的切分（</span></font> slicing off the end of
 a transmission<font size="2"><span style="font-family:simsun,serif">）。  </span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">新添加的功能是在 ATR (自动收/发功能切换)信号的上升和下降沿添加了一个独立的，可配置的精确到一个时钟的时延。在需要配置 ATR （自动收/发功能切换）时，只需调用下面所示的两个新的子板的功能：</span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">    subdev.set_atr_tx_delay(clock_ticks_to_delay_tx) # Rising edge </span></font><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">    subdev.set_atr_rx_delay(clock_ticks_to_delay_rx) # Falling edge </span></font><br style="font-family:simsun,serif"></div><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">... 其中的‘subdev’ 是在使用子板时生成的对象。 </span></font><font size="2"><span style="font-family:simsun,serif">（目前的）</span></font><font size="2"><span style="font-family:simsun,serif"> </span></font><font size="2"><span style="font-family:simsun,serif">困难是如何找出合适的偏置值，这个偏置值能很好的表达从ATR (自动收/发功能)信号突发到子板信号发射完毕的震荡。 </span></font><font size="2"><span style="font-family:simsun,serif">目前采用的方法是让 FPGA 确定应当放置什么值（ 或甚至放置缺省值），但还没有找到一个最好的方法来实现它。不同的外部 Rx/Tx 切换需配置需要不同的参数，没有找到一个统一的答案。 </span></font><font size="2"><span style="font-family:simsun,serif">在这儿给出经验性的估计， 通过 USRP 发射链路的管道时延大约是 50 + 3x (插值速率）个时钟。似乎下降沿需要比这长的时延才能使信号能量降到零，这似乎还同具体的数据相关联。总之最佳值取决于具体的应用。 </span></font><br style="font-family:simsun,serif"></div> </div><div><h3><a name="TOC-USRP-4"></a><font size="2" style="font-family:simsun,serif">USRP<font size="2" style="font-family:simsun,serif">参考</font>时钟的稳定度</font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">什么是 USRP </span></font></b><b><font size="2"><span style="font-family:simsun,serif">参考</span></font></b><b><font size="2"><span style="font-family:simsun,serif">时钟的稳定性？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">时钟具有 20 ppm 的精度，但是在室温的情况，一般都在 5 ppm 内. </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC--4"></a><font size="2"><span style="font-family:simsun,serif">带内发射时间戳  </span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">带内发射时间戳的功用？ </span></font></b></li></ul><ul><ul><li><font size="2"><span style="font-family:simsun,serif">把 FX2 接收</span></font><font size="2"><span style="font-family:simsun,serif">的</span></font><font size="2"><span style="font-family:simsun,serif">数据包送往 FPGA </span></font></li><li><font size="2"><span style="font-family:simsun,serif">FX2 是以整 512 Byte 字节的数据包送往 FPGA </span></font></li><li><font size="2"><span style="font-family:simsun,serif">FPGA 的状态机在处理数据包时做如下工作： </span></font></li></ul></ul></div><div><ul><ul><ul><li><font size="2"><span style="font-family:simsun,serif">检查和确定数据包应该往那儿发送 </span></font></li><li><font size="2"><span style="font-family:simsun,serif">检查和确定 FIFO 存储器是否"满"标志 </span></font></li><li><font size="2"><span style="font-family:simsun,serif">读取数据包的长度  </span></font></li><li><font size="2"><span style="font-family:simsun,serif">填充接受的数据到 FIFO 存储器到“满”或填充完一个完整的数据包  </span></font></li><li><font size="2"><span style="font-family:simsun,serif">如果填充完一个完整的数据包（它一般小于 512 字节）的话，即使还正在接收数据便不考虑后面的（数据流）。  </span></font></li><li><font size="2"><span style="font-family:simsun,serif">否则，数据包将充满整个 FIFO ，发送、回复再填充、直到添完一个完整数据包。 </span></font></li></ul></ul></ul><ul><ul><li><font size="2"><span style="font-family:simsun,serif">FPGA 的命令和信道状态机对 tx_cmd 和 tx_channel 的 FIFO 存储器做如下工作 </span></font></li></ul></ul><ul><ul><ul><li><font size="2"><span style="font-family:simsun,serif">读取数据包的时间戳和长度 </span></font></li><li><font size="2"><span style="font-family:simsun,serif">确保时间戳的未来有效性 </span></font></li><li><font size="2"><span style="font-family:simsun,serif">如果时间戳已经过时，省略该数据包并设置合适的标志位 </span></font></li><li><font size="2"><span style="font-family:simsun,serif">要么等待该时间片结束</span></font></li><li><font size="2"><span style="font-family:simsun,serif">当前的时间片一结束便把数据包的大小发出去 </span></font></li></ul></ul></ul> <h3><a name="TOC--5"></a><font size="2"><span style="font-family:simsun,serif">温度特性</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">纳闷 USRP 温度关联指标</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">USRP 上的所有芯片的温度特性都在 0 - 70 C 的范围。在室温的情况下 USRP 能够连续工作好多天。任何附件单元（子板）都会消耗电源。取决于不同子板，这可高达 15 - 18 Watts。 </span></font><br style="font-family:simsun,serif"></div> <h3><a name="TOC--6"></a><font size="2"><span style="font-family:simsun,serif">本地环回接口 </span></font></h3> </div><div><ul><li><b><font size="2"><span style="font-family:simsun,serif">USRP 上有本地环回接口吗，它如何工作？ </span></font></b></li></ul><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">FPGA 代码有本地环回接口。它通过写 FR_MODE 存储器使能。在 Verilog 代码中查找“loopback", 并查找 fpga_regs_common.{h,v}。 </span></font><br style="font-family:simsun,serif"></div><h3><a name="TOC-USB:-480MBit-sec-32MByte-sec"></a><font size="2"><span style="font-family:simsun,serif">USB: 480MBit/sec =&gt; 32MByte/sec </span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">纳闷为何 USRP 只可达到 32 MBytes/sec. 或者 256 Mbits/sec ，USB 2.0 的特性不是 480 MBits/sec 吗？ </span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">USRP 很容易达到 256 Mbits/s （也就是 32 MByte/sec）。USB 2.0 的信号处理速率可达 480 MBits/sec，或者说 60 MByte/sec。由于数据包头数据和数据包之间的空闲间隔的存在，无法占满整个 480 MByte/sec 的信道。可以通过压缩来扩展一些带宽，但这不是当务之急。USRP 需要双向（双工）通信，这也导致接口芯片中的 8位微处理器也有微码的时延（firmware delays)。 </span></font><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">如果有人对此感兴趣，可以重编该微码（firmware）使得在没有数据传输时，</span></font><font size="2"><span style="font-family:simsun,serif">硬件</span></font><font size="2"><span style="font-family:simsun,serif">使用自动模式。（重编后的）微码应当知道或被告知，什么时候切换为传入或什么时候切换为传出。这也需要占用25%的带宽。 </span></font><br></div> <h3><a name="TOC-RFX:-20MHz-"></a><font size="2"><span style="font-family:simsun,serif">RFX: 20MHz 带宽信号</span></font></h3></div> <ul><li><b><font size="2"><span style="font-family:simsun,serif">只要把发射和接收的频率分开（TX 和 RX 有各自独立的锁相环频率合成器），USRP RFX 子板系列的发射和接受（TX/RX）链路的各自的 20 MHz 的带宽便可用于双工通信。是否有办法在计算机和 RFX 子板之间来移动这 20MHz 带宽的信号？</span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">20 MHz 表示的是基带滤波器的的带宽。所以可以从 LO（本地振荡缓冲器）</span></font><font size="2"><span style="font-family:simsun,serif">任意的上下 +/- 10MHz </span></font><font size="2"><span style="font-family:simsun,serif">来调整。如果使用 16 位采样，只需顾及 USB 的带宽。 </span></font><br style="font-family:simsun,serif"></div><div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">为何 20 MHz 很有用？</span></font><font size="2"><span style="font-family:simsun,serif">有以下三个例证：   </span></font><br></div><div> <div><ul><li><font size="2"><span style="font-family:simsun,serif">可以同时接受或发送两个独立的 4 MHz 宽的用 12 MHz 分割的信号。</span></font></li><li><font size="2"><span style="font-family:simsun,serif">可以用 8 位采样来得到 16 MHz 的带宽。对于射电天文学家，可以用 4 位采样达到 32 MHz 的带宽。</span></font></li><li><font size="2"><span style="font-family:simsun,serif">可以在 FPGA 进行宽带调制解调。可以处理更宽的频带，传输更低速度的信号。</span></font></li></ul><h3><a name="TOC-DC-"></a><font size="2"><span style="font-family:simsun,serif">DC 偏置的去除</span></font></h3><ul><li><b><font size="2"><span style="font-family:simsun,serif">DC偏置是被硬件自动去除的，但是可以</span></font></b><b><font size="2"><span style="font-family:simsun,serif">关闭</span></font></b><b><font size="2"><span style="font-family:simsun,serif">这个特点</span></font></b><b><font size="2"><span style="font-family:simsun,serif">。是否有个代码标志位用来关闭这个特性的？ </span></font></b></li></ul> <div style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">在 "通用寄存器": [ 15 FR_DC_OFFSET_CL_EN DC offset control loop enable ] 下参考： </span></font><font size="2"><a href="usrpfpga.html" style="font-family:simsun,serif" target="_blank">USRP FPGA 文档</a><span style="font-family:simsun,serif">. </span></font><br style="font-family:simsun,serif"></div> <font size="2"><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"></font><div style="text-align:right"><b><font size="2"><span style="font-family:simsun,serif">[</span><a href="usrpfaqintro.html" style="font-family:simsun,serif"> &lt;&lt; USRP 简介</a><span style="font-family:simsun,serif"> | </span><a href="usrpfaq.html" style="font-family:simsun,serif">^ USRP FAQ 首页 ^</a><span style="font-family:simsun,serif"> | </span><a href="usrpfaqfpgaverilog.html" style="font-family:simsun,serif">FPGA/Verilog &gt;&gt;</a><span style="font-family:simsun,serif"> ]</span></font></b><br style="font-family:simsun,serif"></div><font size="2"><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><br style="font-family:simsun,serif"><br><br style="font-family:simsun,serif"></font><p><font size="2"><b><span style="font-family:simsun,serif">注：</span></b></font><b> <font size="2"><a href="http://gnuradio.org/redmine/projects/gnuradio/wiki/UsrpFAQGen" style="font-family:simsun,serif" target="_blank">General Questions</a><span style="font-family:simsun,serif">（原文出处，翻译整理仅供参考!</span><span style="font-family:simsun,serif">）</span></font></b></p></div></div></div></td></tr></tbody></table>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div id="sites-attachments-container">
</div>
</div>
</div> 
</td> 
<td id="sites-chrome-sidebar-right" class="sites-layout-sidebar-right initial" style="width:190px">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_9153814178763965" class="sites-embed" role="navigation"><h4 class="sites-embed-title"> GNURadio 中文社区</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://gnuradio.microembedded.com/" class="sites-navigation-link">GNURadio：中文维客</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="http://gnuradio.microembedded.com/pageindex" class="sites-navigation-link">标题索引：GNURadio</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_3158427237433027" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="/installinggr" jotid="wuid:gx:19c4ea49ca981168" class="sites-navigation-link">GNURadio: 安装指导</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/faq" jotid="wuid:gx:59d38b2d5aff0b87" class="sites-navigation-link">GNURadio: 常见问题</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/tutorials" jotid="wuid:gx:c2443ff1f7a56ec" class="sites-navigation-link">GNURadio: 讲义教程</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/development" jotid="wuid:gx:447c739ef5066bd4" class="sites-navigation-link">GNURadio: 社区贡献</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_6502772558432737" class="sites-embed" role="navigation"><h4 class="sites-embed-title"> GNURadio 最新发布</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="https://sites.google.com/a/microembedded.com/gnuradio/news#TOC-GNU-Radio:-GNU-Radio-release-3.6.3-available-for-download" class="sites-navigation-link">GNURadio 3.6.3</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="https://sites.google.com/a/microembedded.com/gnuradio/news#TOC-GNU-Radio:-GNU-Radio-release-candidate-3.6.3rc0-available-for-download" class="sites-navigation-link">GNURadio 3.6.3rc0</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_4277110048101279" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://gnuradio.microembedded.com/openbts" class="sites-navigation-link">GNURadio - OpenBTS 中文维客 </a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_41189823539683246" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://openbts.microembedded.com/" class="sites-navigation-link">（Range）- OpenBTS 中文社区</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_43043355133298733" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_6312697504782834" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://ossie.microembedded.com/" class="sites-navigation-link">SCA - OSSIE 中文维客</a></div></li></ul></div></div>
</td>
</tr>
</tbody></table>
                    <!-- InstanceEndEditable -->
                    </div>
                </div>
                <div id="sites-chrome-footer-wrapper">
                    <div id="sites-chrome-footer-wrapper-inside">
                        <div id="sites-chrome-footer">
                            <div xmlns="http://www.w3.org/1999/xhtml" class="sites-subfooter">
                                <div class="sites-subfooter-content">
                                    <div dir="ltr">
                                        <div style="text-align:center;font-family:simsun,serif">
                                            <div style="overflow:auto"> <font size="2"><span style="border-collapse:separate;color:rgb(0,0,0);font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px"><span style="text-align:center"><span style="border-collapse:separate;color:rgb(0,0,0);font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px"><span style="border-collapse:collapse">"This is an unofficial translation of the Gnu Radio project homepage.  Please use<span> </span><a href="http://gnuradio.org/">http://gnuradio.org/</a><span> </span> in case of any doubt." 此乃 GNU Radio 非官方中文翻译，如有疑问请参阅<span> </span></span></span><a href="http://gnuradio.org">http://gnuradio.org</a>。<br>
                                                <span style="border-collapse:separate;color:rgb(0,0,0);font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px"><span style="border-collapse:collapse">Chinese translation provided by<br>
                                                <span> </span>
                                                <a href="http://www.microembedded.com/" target="_blank">Microembedded Electronic (Beijing) Co. Ltd.</a><span> </span></span></span><a href="http://www.microembedded.com/" target="_blank">微嵌电子技术（北京）有限责任公司</a>
                                                <span> </span>提供翻译</span></span></font><br><br>
                                                <font>©2009 MicroEmbedded 备案信息：京ICP备15049573号 京公网安备：110108904713</font>
                                                </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="sites-chrome-onebar-footer"> </div>
</body>
<!-- InstanceEnd --></html>