<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" itemscope="" itemtype="http://schema.org/WebPage"><!-- InstanceBegin template="/Templates/gnuradio.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<link rel="shortcut icon" type="image/x-icon" href="../images/sites-16.ico" />
<!--声明当前的页面的编码集-->
<meta charset="utf-8"/>
<meta name="title" content="GNU Radio 中文社区">
<meta itemprop="name" content="GNU Radio 中文社区">
<meta property="og:title" content="GNU Radio 中文社区">
<meta name="description" content="微嵌 - GNU Radio 中文维客 由 微嵌软件技术(北京)有限责任公司维护。GNU Radio 是免费的软件开发工具套件。它提供信号运行和处理模块，用它可以在易制作的低成本的射频（RF）硬件（比如：USRP 和USRP2）和通用微处理器上实现软件定义无线电。这套套件广泛用于业余爱好者，学术机构和商业机构用来研究和构建无线通信系统。">
<meta itemprop="description" content="微嵌 - GNU Radio 中文维客 由 微嵌软件技术(北京)有限责任公司维护。GNU Radio 是免费的软件开发工具套件。它提供信号运行和处理模块，用它可以在易制作的低成本的射频（RF）硬件（比如：USRP 和USRP2）和通用微处理器上实现软件定义无线电。这套套件广泛用于业余爱好者，学术机构和商业机构用来研究和构建无线通信系统。">
<meta id="meta-tag-description" property="og:description" content="微嵌 - GNU Radio 中文维客 由 微嵌软件技术(北京)有限责任公司维护。GNU Radio 是免费的软件开发工具套件。它提供信号运行和处理模块，用它可以在易制作的低成本的射频（RF）硬件（比如：USRP 和USRP2）和通用微处理器上实现软件定义无线电。这套套件广泛用于业余爱好者，学术机构和商业机构用来研究和构建无线通信系统。">
<!-- InstanceBeginEditable name="doctitle" -->
<title>GNU Radio 中文社区</title>
<!-- InstanceEndEditable -->
<meta name="renderer" content="webkit">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
<link rel="stylesheet" type="text/css" href="../css/css.css">
<link rel="stylesheet" type="text/css" href="../css/overlay.css">
</head>
<body xmlns="http://www.google.com/ns/jotspot" id="body" class=" zh_CN">
<div id="sites-chrome-everything-scrollbar">
    <div id="sites-chrome-everything" class="">
        <div id="sites-chrome-page-wrapper" style="direction: ltr">
            <div id="sites-chrome-page-wrapper-inside">
                <div xmlns="http://www.w3.org/1999/xhtml" id="sites-chrome-header-wrapper" style="height:auto;">
                    <table id="sites-chrome-header" class="sites-layout-hbox" cellspacing="0" style="height:auto;">
                        <tbody>
                            <tr class="sites-header-primary-row" id="sites-chrome-userheader">
                                <td id="sites-header-title" class="sites-chrome-header-valign-bottom"><div class="sites-header-cell-buffer-wrapper">
                                        <h2><a href="http://gnuradio.microembedded.com/" id="sites-chrome-userheader-logo"> <img id="logo-img-id" src="../images/logo.jpg" alt="GNU Radio 中文社区" class="sites-logo sites-chrome-header-valign-bottom "></a></h2>
                                    </div></td>
                            </tr>
                            <tr class="sites-header-secondary-row" id="sites-chrome-horizontal-nav">
                                <td colspan="2" id="sites-chrome-header-horizontal-nav-container" role="navigation"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <div id="sites-chrome-main-wrapper">
                    <div id="sites-chrome-main-wrapper-inside">
                    <!-- InstanceBeginEditable name="head" -->
                    <table id="sites-chrome-main" class="sites-layout-hbox" cellspacing="0" cellpadding="{scmCellpadding}" border="0">
<tbody><tr>
<td id="sites-canvas-wrapper">
<div id="sites-canvas" role="main">
<div id="goog-ws-editor-toolbar-container"> </div>
<div xmlns="http://www.w3.org/1999/xhtml" id="title-crumbs" style="display: none;">
</div>
<h3 xmlns="http://www.w3.org/1999/xhtml" id="sites-page-title-header" style="display: none;" align="left">
<span id="sites-page-title" dir="ltr" tabindex="-1" style="outline: none">UsrpFAQFX2</span>
</h3>
<div id="sites-canvas-main" class="sites-canvas-main">
<div id="sites-canvas-main-content">
<table xmlns="http://www.w3.org/1999/xhtml" cellspacing="0" class="sites-layout-name-one-column sites-layout-hbox"><tbody><tr><td class="sites-layout-tile sites-tile-name-content-1"><div dir="ltr"><p><b><font size="3">USB 控制器 FX2 问题 </font></b></p><p style="text-align:right"><b>[ <a href="usrpfaqlatency.html">&lt;&lt; 时延</a> | <a href="usrpfaq.html">^ USRP FAQ 首页 ^</a> ] </b></p><ul><li><h3><a name="TOC-:-USRP-USB-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">断言: USRP 代码 "通过 USB 接口以数据流的形式进入系统" 的方式来处理设备对象，对吗？</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">基本正确，但略复杂于此。USB 支持三种传输方式：命令、海量读写和同步 (isochronous) 方式。使用命令栈(command packets)来配置 USRP、装载固件（firmware）及 FPGA 微码等。标识符 endpoint 0 被用来表示此接口。另外，使用其它的两个 endpoints，一个用于数据输入流另一个用数据输出流。源于 USB 传输支持高速传输，这些 endpoints 也可用于标识海量传输。建议到如下站点 <a href="http://www.usb.org/developers/docs" rel="nofollow">USB 2.0 specification</a> 去阅读第九章的 "USB Device Framework"。它包含构建一个 USB 外设所涉及的大部分知识。</span></font></p><ul><li><h3><a name="TOC-FX2-endpoints-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">FX2 支持多少端口（endpoints）?</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">FX2 支持的 endpoints 是有限的。详细可参阅 <a href="../pdf/CY7C68013.pdf">CY7C68013 Datasheet</a>. 的第 15 页。在此使用的 endpoints 2 和 6 是“四重缓存”（"quad buffered"）, 也就是 4 512 byte 缓存。其一用于 Tx 数据，另一用于 Rx 数据。略施小计可将其扩展为 endpoints 2, 4, 6 和 8、“双重缓存”（"double buffered"）, 也就是 2 512 byte 缓存。这样一来便有 4 簇海量 endpoints（当然报以低速和导致性能不佳的时延）。</span></font></p><ul><li><h3><a name="TOC-tx_buffer-2-x-I-2-x-Q-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">研究 tx_buffer 功能块时发现该功能块交错地发送数据（2 x I 通道、2 x Q 通道）。这理解对吗？</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">它构建了 FX2/FPGA GPIF 接口的发送部分。也担当分离将被发出的数据然后把它送往合适的 DACs 部分。</span></font></p><ul><li><h3><a name="TOC-FX-FPGA-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">FX 重构输入/出 FPGA 的 数据吗？</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">没，FX 没有对入出 FPGA 的数据重构，FPGA 自身负责构建所有数据的类型。FX2 的固件同海量的数据入出没有任何关系。数据传输是依靠 DMA 方式掌控 GPIF 同 FPGA 的 USB 缓存之间的转换来实现的。<br></span></font></p><ul><li><h3><a name="TOC-bus_reset-Used-here-for-the-257-hack-to-fix-the-FX2-bug-bug-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif"> 还有，输入信号 bus_reset 的注释部分，有如此声明 （“Used here for the 257 hack to fix the FX2 bug”）。这里的 bug 是指什么？</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">在 FX2 中，WR 的时序应当比其原本多一个系统时钟（On the FX2, the WR pulse is asserted one clock longer than it should be）。</span></font></p><ul><li><h3><a name="TOC-write_count-WR-FX2-16-I-think-that-along-the-way-I-misunderstood-the-purpose-of-the-write_count-register.-How-does-it-actually-work-WR-triggers-every-time-a-16-bit-packet-is-ready-from-the-FX2-doesn-t-it-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">如若延循曾误解 write_count 寄存器的功用的思路。那么它实际上是如何工作的？WR 是在来自 FX2 的 16 位数据包准备到位时触发，是这样理解吗？ （I think that along the way I misunderstood the purpose of the write_count register. How does it actually work? WR triggers every time a 16 bit packet is ready from the FX2 doesn't it?）</span></font></span></h3></li></ul><ul><li><h3><a name="TOC-FIFO-wreq-WR-write_countr8-WR-256-16-FIFO-FIFO-I-Q-The-wreq-trigger-of-the-FIFO-is-triggered-by-WR-write_countr8-.-Does-this-mean-that-only-256-16-bit-samples-enter-the-FIFO-before-the-WR-is-removed-Why-is-this-How-could-I-determine-exactly-when-there-is-I"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">FIFO 的 wreq 触发器是由 (WR &amp; ～ write_countr8) 触发的。这是否意味着在 WR 有效（为真）之前仅 256 个 16 位的采样被写入 FIFO ？为何如此这般？该如何准确确定何时已有必要写入 FIFO 中的 I 或 Q 采样？<b style="font-style:normal;font-variant:normal;letter-spacing:normal;line-height:normal;text-align:left;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255)">（The wreq trigger of the FIFO is triggered by (WR &amp; ~write_countr8). Does this mean that only 256 16 bit samples enter the FIFO before the WR is removed? Why is this? How could I determine exactly when there is I or Q sample that must be written into the FIFO?）</b></span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">wrreq 决定 FIFO 何时候应该给 FIFO 写数据。也就是，当 (WR &amp; ～ write_countr8) 为真时写入。但当 WR 一旦确定（为真），计数器并没有 0x100 设置位。据笔者回忆，WR 依据一个额外时钟周期，计数器利用其进行触发。（<span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-align:left;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none">wrreq tells the FIFO when data should be written to the FIFO. So, we write when (WR &amp; ~write_countr8). That is, when WR is asserted, but the count does not have 0x100 bit set. As I recall, WR is asserted an extra cycle, and the counter trick works around this.）</span></span></font></p> <ul><li><h3><a name="TOC-FX2-FPGA-have_space-1-USB-FPGA-have_space-TX-When-the-FX2-detects-the-have_space-pin-on-the-FPGA-does-it-transfer-1-entire-buffered-USB-packet-to-the-FPGA-then-re-check-the-have_space-pin-right-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">当 FX2 一旦诊断出 FPGA 上有 have_space（管脚有请求时），便传送 1 个完整的缓存的 USB 数据包到 FPGA，然后再询检管脚它（have_space）是否还为真，（这样便可持续向 TX 输送数据），这理解对吗？（<b style="font-style:normal;font-variant:normal;letter-spacing:normal;line-height:normal;text-align:left;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255)">When the FX2 detects the have_space pin on the FPGA, does it transfer 1 entire buffered USB packet to the FPGA, then re-check the have_space pin, right?</b>）</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">是这样的。Have_space 用来判断 FPGA 是否能够接收更多的数据包，它是通过持续填充 FX 来实现这点的。（重复...）管脚 have_space 是被 FX2 用来判断 FPGA 的 FIFO 能否存储至少一个以上的数据包的。（<span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-align:left;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none">Yes. Have_space is used by the feeding FX2 to know if the FPGA can handle one more packet. The have_space pin is used by the FX2 to know if the FPGA FIFO can store AT LEAST one more packet.</span>）。</span></font></p><ul><li><h3><a name="TOC-512-byte-byte-FPGA-512-byte-byte-Would-it-be-reasonable-to-assume-a-1-clock-delay-between-the-last-byte-of-one-512-byte-packet-being-written-to-the-FPGA-and-the-first-byte-of-a-second-512-byte-packet-being-written-to-the-FPGA-"></a> <span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">前一个 512-byte 的最后一个 byte 的数据包被写入 FPGA 距离下一个 512-byte 的第一个 byte 的数据包是否有一个时钟的时延，这样的推理正确吗？（Would it be reasonable to assume a 1 clock delay between the last byte of one 512-byte packet being written to the FPGA and the first byte of a second 512-byte packet being written to the FPGA?）</span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><font size="2"><span style="font-family:simsun,serif">正确。FX2 通过软件查询管脚。在此数据包之间至少有 100 ns 的间隙，或许远不止此（Yes. That shouldn't be a problem. There's software inside the FX2 that polls the pin. You've got at least 100 ns between packets, probably more. ）。</span></font><br></font></p><ul><li><h3><a name="TOC-USRP-EEPROM-"></a><span style="color:rgb(0,0,0)"><font size="2"><span style="font-family:simsun,serif">任何阐述 USRP 主板上的 EEPROM 的资讯？<br></span></font></span></h3></li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">主板</span></font><font size="2"><span style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">目前</span></font></span></font><font size="2"><span style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">采用 “C2" </span></font></span></font><font size="2"><span style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif">格式 EEPROM 的数据</span></font></span></font></span></font>，这样一来通过代码便可以在上电之初使 9862‘s 处于某种程度的低功耗状态。有关 FX2 的 Boot 的 C0 和 C2 格式的详述可参阅如下：<br></span></font></p><ul><ul><li><font size="2"><span style="font-family:simsun,serif"><a href="../pdf/fx2_trm.pdf">Technical 
Reference Manual - EZ-USB FX2</a> （或 <a href="http://www.keil.com/dd/docs/datashts/cypress/fx2_trm.pdf" rel="nofollow">FX2 Technical Reference Manual</a>.）</span></font></li></ul></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">主板上的 EEPROM 存储着一些 USB 信息、一些十分简单的代码使得在上电之初将系统置于低功耗状态。同时使得其中一个 LED 闪烁加快。一旦着手在 USRP 运行任何应用时，一个完整的固件（它远大于 EEPROM 所能承载）便通过 USB 总线被载入。</span></font></p>
<ul><li><h3><a name="TOC-USRP-Cypress-EZ-USB-FX2-USB-"></a><span style="color:rgb(0,0,0)"><font size="2">USRP 上的 <a href="fx2.html" target="_blank">Cypress EZ-USB FX2 USB 控制器</a> 的工作原理？&nbsp;</font></span></h3> </li></ul>
<p style="margin-left:40px"><font size="2">从如下几个方面着手：</font></p>
<p style="margin-left:40px"><font size="2">1) 资料：<a href="../pdf/CY7C68013.pdf">EZ-USB® FX2™ 
USB Microcontroller - CY7C68013</a> （或官方站点 <a href="http://www-corot.obspm.fr/COROT-ETC/Files/CY7C68013.pdf" rel="nofollow">Official documentation）</a></font></p>
<p style="margin-left:40px"><font size="2">2) 在如下网页可以找到 - </font><font size="2"><a href="http://gnuradio.org/redmine/projects/gnuradio/repository/entry/usrp/firmware/src/usrp2" rel="nofollow">source:usrp/firmware/src/usrp2</a> 主控程序&nbsp; <a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2" target="_blank" rel="nofollow">usrp_main.c</a> (使用 SDCC 对基于 FX2 USB 内的 8051 的编译的固件) ，</font></p>
<p style="margin-left:40px"><font size="2">3) 下面的循环展示主控程序 <a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/usrp_main.c" target="_blank" rel="nofollow">source:usrp/firmware/src/usrp2/usrp_main.c</a> 所涉及（检查）的内容<br></font></p>
<pre style="margin-left:80px"><font size="2"> main( ) <br> {<br></font></pre><div style="margin-left:120px"><font size="2"> Initialize USRP - 初始化 USRP<br> Initialize GPIF - 初始化 GPIF<br> Patch USB Descriptors (read from EEPROM, set HW device ID)&nbsp; - 补丁 USB 描述符（读取 EEPROM、设置硬件设备标识 -  HW ID）<br> Setup Autovectors - 设置 Autovectors<br> Install USB Handlers - 安装 USB 句柄<br> Re-enumerate - 重新枚举<br> Run main_loop( )&nbsp; - 运行 main_loop( ) <br></font></div><pre style="margin-left:80px"><font size="2"> }<br><br> main_loop( )<br> { <br></font></pre><div style="margin-left:120px"><font size="2"> Check for USB setup packets - 检查 USB 配置包<br> Check and log the RX Overruns and the TX Underruns - 检查并记录 RX 链路过载以及 TX 欠载<br> Check for packets to send back to host - 查看数据包返送本机的性能<br> Check for packets to send to FPGA - 查看数据包送往 FPGA 的性能<br></font></div><pre style="margin-left:80px"><font size="2"> }<br></font></pre>
<p style="margin-left:40px"><font size="2">4) USB 端点 - USB Endpoints:</font></p><div style="margin-left:80px"><p><font size="2">不同的 USB 端点 (USB endpoints - EP) 是用来从逻辑的角度来分离总线上的数据流的操作。如前所述在 main_loop() 中用到 3 个 USB 端点。</font></p></div><div style="margin-left:80px"><table border="1" bordercolor="#888" cellspacing="0" style="border-collapse:collapse;border-color:rgb(136,136,136);border-width:1px;margin-left:40px"><tbody><tr><td style="width:256px;height:15px;text-align:center">&nbsp;<b><font size="2">Endpoint （端点）</font></b></td><td style="width:309px;height:15px;text-align:center"><b>&nbsp;<font size="2">Description（描述）</font></b></td></tr><tr><td style="width:256px;height:15px;text-align:center">0</td><td style="width:309px;height:15px;text-align:left"><font size="2">Control/status （控制/标志）</font></td></tr><tr><td style="width:256px;height:15px;text-align:center">2</td><td style="width:309px;height:15px;text-align:left"><font size="2">Host -&gt; FPGA  </font></td></tr><tr><td style="width:256px;height:15px;text-align:center">6</td><td style="width:309px;height:15px;text-align:left"><font size="2">FPGA -&gt; Host </font></td></tr></tbody></table></div> <p style="margin-left:40px"><font size="2">5) USB 的数据传输总是以 512 Byte 为单元。所有的控制信息都使用 endpont 0 和一些制造商提供的命令编写的。这些命令分为两大类：VRT_VENDOR_IN 和 
VRT_VENDOR_OUT。这些都在函数 app_vendor_cmd( ) 中体现。详细信息请参阅如下站点：</font></p><div style="margin-left:40px"><ul><ul><li><font size="2"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/usrp_main.c" rel="nofollow">source:usrp/firmware/src/usrp2/usrp_main.c</a>.</font></li></ul></ul></div>
<p style="margin-left:80px"><font size="2">所有的 FPGA 和 FX2 控制器之间的通信是通过 SPI 来控制的。子板一般都由诸如：VRQ_I2C_* 和 VRQ_SPI_* 命令来掌控。<br></font></p>
<p style="margin-left:40px"><font size="2">6) VRT_VENDOR_IN 命令类:</font></p><div style="margin-left:80px">VRQ_GET_STATUS <br>GS_TX_UNDERRUN <br>GS_RX_OVERRUN <br>VRQ_I2C_READ <br>VRQ_SPI_READ<br></div><p style="margin-left:40px"><font size="2">7) VRT_VENDOR_OUT 命令类:</font></p><div style="margin-left:80px">VRQ_SET_LED <br>VRQ_FPGA_LOAD <br>FL_BEGIN <br>FL_XFER <br>FL_END <br>VRQ_FPGA_SET_RESET <br>VRQ_FPGA_SET_TX_ENABLE <br>VRQ_FPGA_SET_RX_ENABLE <br>VRQ_FPGA_SET_TX_RESET <br>VRQ_FPGA_SET_RX_RESET <br>VRQ_I2C_WRITE <br>VRQ_SPI_WRITE<br></div><ul><li><h3><a name="TOC-USRP-FX2-"></a><span style="color:rgb(0,0,0)"><font size="2">USRP FX2 的工作原理？ </font></span></h3></li></ul><p style="margin-left:40px"><font size="2">FX2 控制器中包含一个嵌入式的 USB2.0 收发器来处理所有的 USB 同其上位宿主机之间的传输。它<font size="2">表现为</font>一个同外部世界（在此言指 FPG）相连的数据总线，它具有通过编程可定制控制的通用控制信号。此接口便是 GPIF（General Purpose Interface）。<br></font></p><p style="margin-left:40px"><font size="2">FX2 也可以（通过 endpoint 0 来）掌控所有的 USB 控制请求，所要求的是所有的具有 USB 功能的设备必须完全兼容并支持 USB (协议)标准。也包含对设备诊断的反应以及（协议）标准的配置的请求。<br></font></p><p style="margin-left:40px"><font size="2">FX2 内部原理框图如下（由 Kalen Thesis 提供）</font></p>
<p><font size="2"><img src="../images/FX2-internal.jpg" style="display:block;margin-right:auto;margin-left:auto;text-align:center"></font></p> <div><p style="margin-left:40px"><font size="2">FX2 的工作原理简图如上所示。它包含一个工业标准级的用于处理所有的内部控制的 8051 控制器的核（一些功能的延伸和性能的提升）。此 8051 对实际掌控 USB 工作的收发器进行初始化；同时也肩负配置 FX2 的通用 I/O 端口（上图未显示）和 GPIF 的状态机。USB 的数据传输是通过端口（endpoints）实现的，其机理类同以太网的<span>套接字(</span>socket<span>)。每个端口（</span>endpoints<span>）必须明示数据流方向，或者是 IN 或者是 OUT（以 USB 为核心），但端口 0 （</span> endpoint 0 <span>）是唯一的例外，它可以双向传输。端口还必须明示其传输的数据类型以昭其对带宽的需求。<br></span></font></p><p style="margin-left:40px"><font size="2">数据入出 USB 宿主（控制器 FX2）侧被存储在 FIFO 的端口（ENDPOINT FIFOs），它可被配置成各种大小和各种级别的缓存方式。GPIF 可以直接读取这些 FIFO's，这使得数据可以在外部设备和 USB 宿主之间通过系列的 FIFO 缓存器实现无缝传输。</font></p>
<ul><li><h3><a name="TOC-FX2-"></a><span style="color:rgb(0,0,0)"><font size="2">如何理解 FX2 固件?</font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">除日常常规的杂务和配置之外，FX2 固件还肩负如下责任：<br></font></span></p><ul><ul><li><span style="font-family:simsun,serif"><font size="2"><b>GPIF 初始化：</b>不只仅仅是试图以 USB2.0 高速(480MBits/s) 直接进行数据传输，GPIF 主要承载数据的传输。 FX2 的 8051 核对该接口实施初始化。<br></font></span></li><li><span style="font-family:simsun,serif"><font size="2"><b>USB 控制请求处理：</b>8051 核处理来自 USB 宿主通过 endpoint 0 的控制请求。所有的 USB 兼容设备对此类的标准（译者注：USB 2.0 标准）请求依据标准回应（比如，通过 GetDeviceName 之类回馈设备的描述）。<br></font></span></li><li><span style="font-family:simsun,serif"><font size="2"><b>USB 传输请求：</b>这通过构建<span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:18px;text-align:start;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none">轮询循环（</span></font></span><span style="font-family:simsun,serif"><font size="2"><span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:18px;text-align:start;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none"><span style="font-family:simsun,serif"><font size="2">polling loop</font></span>）来实现。当或需要接收到来自宿<font size="2">主（host）的请求时，它便</font>载入 GPIF 承载传输参数的</span></font></span><span style="font-family:simsun,serif"><font size="2"><span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:18px;text-align:start;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none"><span style="font-family:simsun,serif"><font size="2"><span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:18px;text-align:start;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none">配置</span></font></span>寄存器。FX2 固件是通过 C <font size="2">语言编写<font size="2">，并由开源编译器编译的<font size="2">，这编译器就是 SDCC</font></font></font></span></font></span><span style="font-family:simsun,serif"><font size="2"><span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:18px;text-align:start;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none"><font size="2"><font size="2"><font size="2"><span style="font-family:simsun,serif"><font size="2"> (Small Device Cross Compiler)。其内嵌的功能<font size="2">是通过<font size="2">使用</font> </font></font></span></font></font></font></span></font></span><span style="font-family:simsun,serif"><font size="2">usrp_basic 及 usrp_prims libraries 来实现的。<br></font></span></li></ul></ul><ul><li><h3><a name="TOC-FX2-GPIF-"></a><span style="color:rgb(0,0,0)"><font size="2">FX2 GPIF 的功用? </font></span></h3></li></ul><p style="margin-left:40px">GPIF（General Purpose Interface）的构建使得 FX2 能够简单地同多种不同的设备接口。本质上，它是带有一组由可配置状态机控制的通用控制信号的双向数据总线。GPIF 可被配置成总线主设备（bus master）或受设备驱动的总线从设备（bus slave）。GPIF 作为总线主设备的情况，有六个状态可被用来描述一个特定任务的时序（waveforms）。依据通用控制电平的大小（the values of the generic control lines）通过决策点（<span style="font-family:Verdana,sans-serif;font-size:13px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-align:left;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none">decision points</span>）决定其状态的转换。</p><p style="margin-left:40px">下面是其四种可供选择的描述特定任务的总线时序：<br></p><ul><ul><li><b>只写（Single Write）:</b> 该总线时序完成将一个单独数据从 USB 写到设备的过程（所有的过程都是以 USB 作为中心）</li><li><b>只读（Single Read）:</b> 该总线时序完成将一个单独数据从设备读到 USB 的过程 </li><li><b>先入先出读（FIFO Write）:</b> 该总线时序基于预先的配置参数完成对一组数据的写的过程。在这些数据的传输过程中可能会受到接收设备的阻塞。&nbsp;</li><li><b><b>先入先出写（</b>FIFO Read）:</b> 该总线时序完成从设备对一组数据的读的过程，它可被用来读取 ADC 的数据流到宿主计算机。 下面是一个简化的 GPIF FIFO Read 时序图。 </li></ul></ul><p style="margin-left:40px">GPIF 时序例图 (源于 Kalen Thesis 提供)</p><p><img src="../images/gpifexampleow7.jpg" style="display:block;margin-right:auto;margin-left:auto;text-align:center"></p> <div style="margin-left:40px"><p><span style="font-family:simsun,serif"><font size="2">GPIF 具有六个控制信号输入 RDY5:0 和六个控制信号输出 CTL5:0。这足以使其总线控制时序呈现基于标准的多样性及专属性。如上图所示，位于 state 1 的决策点（<span style="font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-align:left;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px;background-color:rgb(255,255,255);display:inline!important;float:none">decision points</span>）将保持其原有状态（stalled state）直到 RDY0（在此其诠释 FIFO 空标志）将其释放。与此同时 GPIF 状态机便转入 state 2 并且将此时呈现在数据总线的数据捕获。FX2 通过内部端口（internal endpoints）以 EP0、EP1、EP2、EP4、EP6 及 EP8 形式构建 USB 的端口（endpoints）, 它可以通过多种方式被配置来适应应用程序对缓存的需求。EP0 通常被配置成一个 64 byte CONTROL endpoint；EP1 仅可能被配置成一个 BULK 或 INTERRUPT 类型 (它也是 64 bytes)。其余的可被配置成最大容积 4K 的双倍缓存、三倍或四倍缓存。正是通过这种方式，数据得以能够持续的流入或流出宿主设备，在恰当的时机便能够提供恰当的流控制。<br></font></span></p><p><span style="font-family:simsun,serif"><font size="2"><font size="2">Cypress Semiconductor 提供一款先进的 GPIF 设计工具，</font></font></span><span style="font-family:simsun,serif"><font size="2"><font size="2"><span style="font-family:simsun,serif"><font size="2">GPIF Designer。</font></span>它可以通过图形界面对 GPIF 状态机进行设计。该软件允许用户对状态机进行定制设计，随后生成配置及初始化用<font size="2">的相应的</font>代码，这些代码可被融合到 FX2 核心固件中。它使得配置 GPIF 状态时序<font size="2">寄存器</font>这种需要</font></font></span><span style="font-family:simsun,serif"><font size="2"><font size="2"><span style="font-family:simsun,serif"><font size="2"><font size="2">繁琐的</font></font></span>人工编程的工作得以简化。</font>针对 USRP 情况而言，开发人员选择对 </font></span><span style="font-family:simsun,serif"><font size="2">GPIF Designer 产生的代码进行语法分析（Parse)，并添加他们自己的初始化例程。该项工作被中途搁置，原因是 </font></span><span style="font-family:simsun,serif"><font size="2">GPIF Designer 产生的代码模糊不清（它招致的代码问题制约着 GUN <font size="2">Radio <font size="2">研究小组的进程）。</font></font></font></span></p></div><p style="margin-left:40px"><span style="font-family:simsun,serif">在 USRP 内部，GPIF 的工作独立于 FX2 8051 的核，其工作原理是通过对内部先入先出端口寄存器（</span>internal FIFO endpoints）读取数据，然后相应地将数据写入 USB 宿主设备中，相反过程是将 USB 宿主设备中读取的数据写入到 FIFO 端口中。在程序中 FX2 接口的工作机理是通过 usrp_prims 和 usrp_basic 的源码及一些头文件（header files）来体现的。</p><p style="margin-left:40px">Usrp_prims 定义了一组用来扩展 USB 各种通用功能的函数，该函数组是基于针对 FX2 如何回应 USB 的端口 endpoint 0 的产生的控制请求的目的来构建的。这些函数的参数（function primitives）通常担当从 FX2 各种寄存器里读取或写入数据的角色，及充当通过 GPIF 来引导或初始化数据的传输的功能。<br></p><p style="margin-left:40px"> </p><p style="margin-left:40px">Usrp_basic 提供了一个面向对象（object-oriented）的程序构架下来使用函数组 usrp_prims 的简单的 API 接口。以系统眼光来看，该接口展示较高层面的功用同时也将其大多数底层机理隐藏起来。<br></p><ul><li><h3><a name="TOC-usrper-"></a><span style="color:rgb(0,0,0)"><font size="2">软件工具<font size="2"> </font>usrper 的功用？</font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">这是一款数据流测试的软件。它可用于装载 FPGA 配置用的数据（串行地将数据载入 FPGA 位表配置列表中），确认 USRP 诊错指示灯，及对 USRP 进行数据的读写操作。<br></font></span></p><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">在启动之初，usrper 首先试图建立一个能够同有效 USRP 设备进行通信的接口对象（interface object）。这将生成一个通用 USB 设备句柄，通过遍历（traverses）所有同 USB 连接的设备，寻找 FX2 的厂家及产品 ID 信息（分别对应 0x04B4 及 0x8613）。一旦发现一个已经上电、但未配置的 FX2 设备，</font></span><span style="font-family:simsun,serif"><font size="2">usrper 便会通过将 GnuRadio 固件载入该 FX2 设备中进行系统配置，同时该固件用重新定义过的</font></span><span style="font-family:simsun,serif"><font size="2">的厂家及产品 ID 信息</font></span>覆盖设备原有信息并通过软件复位方式进行初始化，所有这一切会导致该 FX2 同宿主 PC 设备的断开及再连接。<br></p><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">这个过程被称之为</font>重枚举（</span><span style="font-family:simsun,serif"><span style="font-family:simsun,serif"><font size="2">re-enumeration</font></span>），Linux 内核这时便可认可一个产品及厂家 ID 分别为 </span><span style="font-family:simsun,serif"><font size="2">0xFFFE 和 0x0002 的 USB 类型的 USRP 设备。它同经由 FSF 开发并配置的 USRP 的（逻辑上的）设备相<font size="2">对应。</font><br></font></span></p><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">完成上面</font>这些步骤之后，通过调用 USRP 关联的函数调用（function method)便可对其读写及控制请求。<br></span></p><ul><ul><li><b>控制请求 - Control requests </b></li></ul></ul><p style="margin-left:80px">通过 USB 端口（endpoint）0，对 USRP 系统的多个方面进行激活或者配置。固件呼应这些调用（所有的来自宿主设备的对 USB 控制请求以中断形式呼应）并对其进行响应。这些来自宿主设备的控制请求参数这时便会被载入或载出内部寄存器，通过这种对控制请求的呼应及响应便可达到扩展其原始的功用的目的。<br></p><p style="margin-left:80px">以下载 FPGA 固件为例，通过端口（endpoint）0 将请求配置 FPGA 用的相关的参数以配置位表数据（bit stream 
data）格式载入。FX2 以字节（byte)形式呼应该数据流，以位操作形式下载到（bitwise）FPGA 的配置列表（Altera 公司的 EP1C12 FPGA 支持串行数据处理模式）。在呼应该处理控制请求的同时，FX2 固件也回送宿主设备相应的握手信号作为响应来展示对该原始控制请求的完整处理过程。</p><ul><ul><li><b>读取请求 - Read requests </b></li></ul></ul><p style="margin-left:80px">USB 从 USRP 设备读取数据的请求是通过（被配置为以 512 byte 的海量输入模式的）端口 2 （endpoint 2）来实现的。FX2 呼应这些请求并基于这些控制请求参数修正并配置并保持 GPIF 状态机随后释放这些对 GPIF 的请求。<br></p><p style="margin-left:80px">GPIF 一旦进入 FIFO 读状态便会将该状态保持直到数据传输过程完结或传输错误出现为止。FX2 固件以极其明晰的步骤呼应所有的请求并回馈握手信号对其呼应以响应。<br></p><ul><ul><li><b>写入请求 - Write requests </b></li></ul></ul><p style="margin-left:80px">如同上面读取请求过程相似，宿主 PC 对 USB 的常规写入请求是通过（被配置为以 512 byte 的海量输出模式的）端口 6 （endpoint 6）来实现的。GPIF 配置 FIFO 写状态并保持该状态直到数据传输过程完结或传输错误的出现为止。</p><ul><li><h3><a name="TOC-FX2-USRP_PRIMS.CC---What-does-the-FX2-low-level-interface-library-USRP_PRIMS.CC-do-"></a><span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)">FX2 的底层接口库文件（USRP_PRIMS.CC）的功用？ - What does the FX2 low-level interface library (USRP_PRIMS.CC) do? </span></font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">该代码库构建了一组</font></span><span style="font-family:simsun,serif"><font size="2"><span style="font-family:simsun,serif"><font size="2">同 FX2 的直接接口</font></span>的底层函数。通过端口<font size="2"> 0 <font size="2">将数据及<font size="2">各种</font>控制请求</font></font>传递给 FX2，<font size="2">相应<font size="2">地，数据的<font size="2">回传接收是通过端口 2（</font></font></font></font></span><span style="font-family:simsun,serif"><font size="2"><font size="2"><font size="2"><font size="2"><span style="font-family:simsun,serif"><font size="2">endpoint 2</font></span>）。</font></font><br></font></font></span></p><ul><li><h3><a name="TOC-1"></a> </h3><h3><a name="TOC-FX2-USRP_BASIC.CC---What-does-the-FX2-application-level-interface-library-USRP_BASIC.CC-do-"></a><span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)">FX2 的应用层接口库文件（USRP_BASIC.CC）的功用？ - What does the FX2 application-level interface library (USRP_BASIC.CC) do? </span></font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">该代码库呈现出一个同 FX2 的高级接口。<font size="2">在 </font></font></span><span style="font-family:simsun,serif"><font size="2"><font size="2"><span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/host/lib/legacy/usrp_prims.cc" rel="nofollow">source:usrp/host/lib/legacy/usrp_prims.cc</a></span></font></span> 内，它</font>以面向对象的程序构架来<font size="2">调用函数</font>。<br></font></span></p><ul><li><h3><a name="TOC-GPIF---Why-do-we-use-GPIF-mode-"></a> <span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)">何故采用 GPIF 模式？ - Why do we use GPIF mode? </span></font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">通过 GPIF 模式来使用 FX2<font size="2"> 的原因是通过 GPIF 接口数据的<font size="2">迸<font size="2">发速率<font size="2">可达 96 MB/sec。</font></font></font><br></font></font></span></p><ul><li><h3><a name="TOC-USRP-FX2---0-endpoint-0-FX2-FPGA-USRP-FX2-interface---As-I-understand-it-all-control-calls-to-endpoint-0-are-handled-within-the-FX2-and-do-not-require-the-involvement-of-the-FPGA-right-"></a> <span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)">USRP-FX2 接口 - 所有的控制对端口 0 （endpoint 0）的调用都发生在 FX2，同 FPGA 丝毫没有牵连，这样的断言正确吗？（USRP-FX2 interface - As I understand it, all control calls to endpoint 0 are handled within the FX2 and do not require the involvement of the FPGA, right?）</span></font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">是，正确。</font></span></p><ul><li><h3><a name="TOC-GPIF-FPGA-firmware---GPIF-waveform-configurations-"></a> <span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)">GPIF / FPGA firmware - 总共有几种 GPIF 时序配置（waveform configurations）? </span></font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">两种：FIFORd 及 FIFOWr </font></span></p><ul><li><h3><a name="TOC-FPGA-FX-8051---Do-you-handle-FPGA-configuration-explicitly-using-the-FX-8051-core-"></a> <span style="font-family:simsun,serif"><font size="2"><span style="color:rgb(0,0,0)">FPGA 的配置明确地用到 FX 8051 核吗？ - Do you handle FPGA configuration explicitly using the FX 8051 core? </span></font></span></h3></li></ul><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">FX 8051 采用 <a href="http://baike.baidu.com/view/3046808.htm" target="_blank" rel="nofollow">Bit-Banging</a> 技术来处理 FPGA 的配置。</font></span><br></p><ul><li> <b>敬请告知描述 </b><b><b>GPIF CTLx/RDYx 电平及时序的</b> FX2 源码的位置？&nbsp;</b>
</li></ul><p style="margin-left:40px">工具使用的是 Cypress GPIF designer。详情请参阅：<span style="color:rgb(0,0,0)"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/common/gpif.gpf" rel="nofollow">source:usrp/firmware/src/common/gpif.gpf</a>.</span></p>
<ul><li> <b>如何将使用速度可达（</b><b><b>480Mbit/sec</b>）的 USB 2.0 的 USRP 改制为使用全速仅达</b><b><b>(12Mbyte/sec) 的 USB 1.1</b>。在这里 USB 1.1 是以 64 byte 构建</b><b><b>数据包；相应的 </b>USB2.0 使用 512 
byte </b><b><b>的数据包</b>?</b><br><p><font size="2"><span style="font-family:simsun,serif">或许需要修改部分固件。而且需要将其抽取到很低的数据速率，这样便不会产生溢出。</span></font></p><p><font size="2"><span style="font-family:simsun,serif">注：有关 USRP 使用 USB 1.1 请参阅补丁（<a href="http://lists.gnu.org/archive/html/discuss-gnuradio/2006-04/msg00284.html" rel="nofollow">patch</a>）。</span></font><br></p></li></ul>
<ul><li> <p><font size="2"><span style="font-family:simsun,serif"><b>实施如上建议的修改，似乎不难看到数据的产生，但其格式还是 64 bytes，然后便有 </b><b><b>5 microseconds 的“难产”。现象催生如此疑问“PC 无法通过 USB 进行快速数据处理”。</b>也自然产生下面联想“有无可能在 FPGA 动手从 FX2 读取数据之前先将 FX2 芯片内的缓存填满？”。</b></span></font></p> </li></ul><p style="margin-left:40px"><font size="2"><span style="font-family:simsun,serif">问题的解决是通过 FX2 代码将数据块传输大小的格式设置成 64 bytes。原因是，宿主 PC 机以 64 byte 发送数据，但未经代码修改的 FX2 却无视数据的真实大小的格式，仍以原来的 512 bytes 的格式进行数据（接收）处理。在此强调在以 USB2.0 为约定的传输协议中，GPIF 的配置参数是 DMA 256 16-bit。这或许也是需要被修改的部分。<span style="color:rgb(0,0,0)">这些神奇的参数有可能隐藏在 </span><span style="color:rgb(0,0,0)"><span style="color:rgb(0,0,0)">usrp_gpif.c 的</span> <a href="http://lists.gnu.org/archive/html/discuss-gnuradio/2005-04/msg00184.html" target="_blank" rel="nofollow">WaveData</a> 表格中。<br></span></span></font></p><p style="margin-left:40px"><span style="font-family:simsun,serif"><font size="2">还有一件必须处理的事情是将 GPIF 配置为非流畅（non-flowstate）模式。这可以通过使用 Cypress 的工具来完成（或者<font size="2">使用</font> Larry 
Doolittle's perl 代码？）。 它可使数据传输处于全速。在这种情况下，FX2 同 FPGA 之间的<font size="2"><font size="2"><font size="2"> 96 MB/sec 的迸<font size="2">发速率<font size="2">没有必要. </font><br></font></font></font></font></font></span></p>
<ul><li> <b><font face="simsun, serif" size="2">使用 Cypress 工具来研究 GPIF 原理，没有发现任何关联数据传输大小的格式的地方。断言其配置是由 FPGA 完成，对吗？</font></b></li></ul><p style="margin-left:40px"><font face="simsun, serif" size="2">不对，这种理解是错误的。正确的理解仍旧是 GPIF 负责数据传输问题。这种现象产生的原因是在系统程序被规划完善后呈现出的 FX2 以 256 为单元迸发式数据传输的现象。在此换个话题，这类问题的解决是离不开 逻辑分析仪（笔者的观点）。GPIF 总线当时到底发生什么问题？（将 GPIF 相关管脚或针通过接插件延伸到子板的测试点上）<br></font></p><p style="margin-left:40px"><font face="simsun, serif" size="2">查阅 <a href="../pdf/fx2_trm.pdf" target="_blank">FX2 技术参考手册</a>（或者尘封的记忆）的第 10-16 页（10.3.2.2.2&nbsp;的决策点部分 -&nbsp;10.3.2.2.2 Decision Point States）便不难发现时序决策点是由“事件计数复位 -&nbsp;Transaction Count Expired”信号来控制的。在第 10-24 页所描述“逻辑功能寄存器”，TERMA 及/或者 TERMB，是由代码表现为 RDY5 （这便是所谓的事件计数复位 -&nbsp;Transaction Count Expired，或者</font><span style="font-family:simsun,serif;font-size:small">&nbsp;</span><span style="font-family:simsun,serif;font-size:small">GPIFREADYCFG.5 = 1）。有关“</span><span style="font-family:simsun,serif;font-size:small">事件计数 -&nbsp;</span><span style="font-family:simsun,serif;font-size:small">Transaction Counter</span><span style="font-family:simsun,serif;font-size:small">”详情请参阅第 10-41 的第&nbsp;</span><span style="font-family:simsun,serif;font-size:small">10.4.3.1 部分。</span></p><p style="margin-left:40px">欲意将<span style="font-size:small;font-family:simsun,serif">事件计数（</span><span style="font-size:small;font-family:simsun,serif">Transaction Counter）用于 FIFO "x"，载入带有欲处理事件数的参数的&nbsp;</span><span style="font-family:simsun,serif;font-size:small">GPIFTCB3:0 便可。一旦 FIFO 在时序上触发&nbsp;</span><span style="font-family:simsun,serif;font-size:small">FIFO-READ 或 -WRITE，GPIF 便会将特定数目的字节 - byte（如若&nbsp;</span><span style="font-family:simsun,serif;font-size:small">WORDWIDE=1 字节在这里便是一个字 - word)。</span></p><p style="margin-left:40px"><span style="font-family:simsun,serif;font-size:small">详情请参阅下面的 ### HERE ### 部分 (代码源自于&nbsp;</span><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/src/usrp2/usrp_main.c" style="font-family:simsun,serif;font-size:small" rel="nofollow">source:usrp/firmware/src/usrp2/usrp_main.c</a><span style="font-family:simsun,serif;font-size:small">):</span></p><p style="margin-left:40px"><font face="simsun, serif" size="2">在这里将 256 改为 32 了吗？没，这或许正是问题所在。</font></p><p style="margin-left:40px"><span style="font-family:simsun,serif">&nbsp; &nbsp; </span><font face="simsun, serif" size="2">&nbsp; &nbsp;// Next see if there are any "OUT" packets waiting for our attention, &nbsp;- （下面查看是否有任何“OUT" 数据包待处理，）</font></p><pre style="margin-left:40px"><font face="simsun, serif" size="2">       // and if so, if there's room in the FPGA's FIFO for them. - （若如有，查看 FPGA 的 FIFO 是否有空间。）<br><br>       if (g_tx_enable &amp;&amp; !(EP24FIFOFLGS &amp; 0x02)){  // USB end point fifo is not empty...  （USB 端口 fifo 非空闲 ...)<br><br>         if (fpga_has_room_for_packet ()){   // ... and FPGA has room for packet ( ... FPGA 有空闲空间）<br><br>           GPIFTCB1 = 0x01; SYNCDELAY;        #######  HERE ####### <br>           GPIFTCB0 = 0x00; SYNCDELAY;        #######  HERE ####### <br><br>           setup_flowstate_write (); <br><br>           SYNCDELAY; <br>           GPIFTRIG = bmGPIF_EP2_START | bmGPIF_WRITE; // start the xfer <br>           SYNCDELAY; <br><br>           while (!(GPIFTRIG &amp; bmGPIF_IDLE)){ <br>             // wait for the transaction to complete （等待处理过程的完结）<br>           } <br>         } <br>       } <br><br>       // See if there are any requests for "IN" packets, and if so （下面查看是否有任何“IN" 数据包待处理，）</font></pre><pre style="margin-left:40px"><font face="simsun, serif" size="2">       // whether the FPGA's got any packets for us. （查看 FPGA 是否获取任何数据。）</font></pre><pre style="margin-left:40px"><font face="simsun, serif" size="2"><br>       if (g_rx_enable &amp;&amp; !(EP6CS &amp; bmEPFULL)){ // USB end point FIFO is not full... （USB 端口 FIFO 尚存空间...）<br><br>         if (fpga_has_packet_avail ()){ // ... and FPGA has packet available (... FPGA 获取到数据)<br><br>           GPIFTCB1 = 0x01; SYNCDELAY;       ####### HERE ####### <br>           GPIFTCB0 = 0x00; SYNCDELAY;       ####### HERE ####### <br><br>           setup_flowstate_read (); <br><br>           SYNCDELAY; <br>           GPIFTRIG = bmGPIF_EP6_START | bmGPIF_READ; // start the xfer （传输开始）<br>           SYNCDELAY; <br><br>           while (!(GPIFTRIG &amp; bmGPIF_IDLE)){ <br>             // wait for the transaction to complete </font><span style="font-family:simsun,serif;font-size:small">（等待处理过程的完结）</span><font face="simsun, serif" size="2"><br></font><font face="simsun, serif" size="2">           } <br><br>           SYNCDELAY; <br>           INPKTEND = 6; // tell USB we filled buffer (6 is our endpoint num) - 告知 USB 缓存满 （端口编号 6）<br>         } <br>       }<br></font></pre></div><blockquote style="margin:0 0 0 40px;border:none;padding:0px"><p><span style="font-family:simsun,serif;font-size:small">除非很幸运对&nbsp;</span><span style="font-family:simsun,serif;font-size:small">####### HERE ####### 做过修改，逻辑分析仪便是解决此类问题的必由之路。</span></p></blockquote><div><ul><li> <span style="font-family:simsun,serif"><b>欲意编写用于 Windows 及 USRP 的 USB 驱动；何处查找有关 USRP 的 USB 资讯。&nbsp;</b></span>
<p>请参阅:</p>
<p style="margin-left:40px"><span style="color:rgb(0,0,0)"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_interfaces.h" rel="nofollow">source:usrp/firmware/include/usrp_interfaces.h</a></span></p>
<p style="margin-left:40px"><span style="color:rgb(0,0,0)"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_commands.h" rel="nofollow">source:usrp/firmware/include/usrp_commands.h</a></span></p></li></ul>
<ul><li><b>可有人知悉何处可以获得有关传输在接口（<b>interface</b>）0，1，2（或者 ep0, ep2 及 ep6) 上 USB 的数据结构的文档资讯来帮助人们来构建它们。ep0 数据结构被认为是缺省的控制流程管线（</b><b>control pipe）上的</b>&nbsp;<b>USB 设备请求用的构架，同时也有人认为比起标准的 USB 有更多的控制请求。</b></li></ul></div><blockquote style="margin:0 0 0 40px;border:none;padding:0px"><p><b>另外一个问题是，vendor id 是一个规则极其混乱的设备类型标识。这会使人产生疑惑，如何确认所连接的设备是被确认的 USRP 设备；进而令人颇感疑惑的是如果连接 FX2 芯片的设备被确认是非 USRP 设备而且也未初始化，如何进行“是同 FX2 连接"的确认、"是同 USRP 设备"或"同非 USRP 设备"的连接的确认？&nbsp;</b></p></blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px"><p>所有交予用户的 USRP 设备上都烧结一个&nbsp;non-Cypress USB VID/PID 。USRP 设备同一个未被程序化的 FX2 不应产生任何疑惑。USRP 规定：VID = 0xfffe, PID = 0x0002 。通过 DID 来进一步区分板块的版本号及固件（firmware）是否被装载。</p></blockquote><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><div><p>详细资讯请参阅：<a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_ids.h" rel="nofollow">source:usrp/firmware/include/usrp_ids.h</a>.</p></div><div><p>下面链接中的一个头文件（.h files）几乎包括了所有的关于如何控制 USRP 的问题的回答</p></div></blockquote><blockquote style="margin:0 0 0 40px;border:none;padding:0px"><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><div><p><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include" rel="nofollow">source:usrp/firmware/include</a>.&nbsp;</p></div></blockquote></blockquote><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><p>更详细的请参阅；&nbsp;</p></blockquote><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><p><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/fpga_regs_common.h" rel="nofollow">source:usrp/firmware/include/fpga_regs_common.h</a>&nbsp;</p></blockquote><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><p>和&nbsp;</p></blockquote><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><p><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/fpga_regs_standard.h" rel="nofollow">source:usrp/firmware/include/fpga_regs_standard.h</a>&nbsp;</p></blockquote></blockquote><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><p>可获得 FPGA 中的配置用寄存器的功能定义。</p></blockquote><div>
<ul><li><b>如果对 USB 的底层编程技巧一无所知，如何驾驭 Linux 环境中的 Cypress 芯片的驱动问题。</b></li></ul></div><blockquote style="margin:0 0 0 40px;border:none;padding:0px"><div>无需任何驱动的编程，使用 <a href="http://libusb.sf.net/" rel="nofollow">libusb</a>&nbsp;便可。</div></blockquote><div>
<ul><li> <b>如何确保在同系统相连时用户 USB 设备使用了恰当的驱动？&nbsp;</b><p>下面是些大致的步骤：&nbsp;</p>
</li></ul><ol><ol><li>在&nbsp;
<a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/firmware/include/usrp_ids.h" rel="nofollow">source:usrp/firmware/include/usrp_ids.h</a>&nbsp;中定义该 USB 的 PID（product ID）并使开发人员知悉这些。</li><li>更改&nbsp;host/lib/usrp_prims.cc 使其不仅接纳常规 USRP 设备（的 PID）也接纳该 PID 。</li><li>使用&nbsp;
usrper i2c_write 为该 PID 所代表的 USB 设备编写 FX2 EEPROM 代码。</li><li>在&nbsp;
/etc/hotplug/usb/ 中添加 usermap 文档及初始化脚本（initialization script）。</li></ol></ol>
<ul><li><b>对现有的 FX2 固件进行针对性修改以便用于测试的想法可行吗？</b><p>完全可行。可以先使用略加修改的&nbsp;usrper 及 test_usrp_standard_rx 使得设备先动起来，然后便可基于各种库文件再构建其完备的针对性的可执行文件。</p></li></ul>
<ul><li> <b><font face="simsun, serif">构建基于 USRP 的板件时，试图避免对 FX（8051）的源代码进行重新编译的想法是否可行。是否有途径可直接对 FX 寄存器进行写操作？可否将 CLK 的频率输出从缺省的 12 MHz 改为 24 MHz。</font></b><p><font face="simsun, serif">No command.&nbsp;<font style="font-size:small;line-height:18px">No</font><span style="font-size:small;line-height:18px">&nbsp;</span><font style="font-size:small;line-height:18px">comment</font><span style="font-size:small;line-height:18px">&nbsp;无言相对! USRP 在载入固件之后 FX2 运行在 48 Mhz。</span></font></p></li></ul>
<ul><li> <b>曾有这样说法，USRP FPGA FIFO 缓存（Buffers ）具有 2K 行（lines）的规模。这是否可以解释为 2048 位（bits）呢?</b>
<p>错，它是说 2K 行（2K lines），何况每行就有 32 位（bits）。FX2 对于发送（TX）及接收（RX）的缓存都采取四倍缓存（quad buffering）技术来构建，其缓存的大小是 512 bytes 。</p></li></ul>
<ul><li><font face="simsun, serif" size="2"><b>USRP 在通过 USB 传输数据的过程中，参数 fusb_nblock 及 fusb_block_size 
的准确含义?</b>
</font><p><font face="simsun, serif" size="2">参数&nbsp;fusb_block_size 表述一个内核对用户空间（user-space）进行读写的以 bytes 为单位的最大传输空间。参数&nbsp;fusb_nblock&nbsp;表述一个在特定时间段内（</font><span style="font-family:simsun,serif;font-size:small">相对应&nbsp;</span><span style="font-family:simsun,serif;font-size:small">fusb_block_size 所描述的</span><span style="font-family:simsun,serif;font-size:small">最大传输空间的</span><span style="font-family:simsun,serif;font-size:small">）</span><span style="font-family:simsun,serif;font-size:small">最大传输数量。详情请参阅</span></p><blockquote style="margin:0px 0px 0px 40px;border:none;padding:0px"><p><span style="color:rgb(0,0,0)"><font face="simsun, serif" size="2"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/host/lib/fusb_linux.h" rel="nofollow">source:usrp/host/lib/fusb_linux.h</a>&nbsp;</font></span></p><p><span style="color:rgb(0,0,0)"><font face="simsun, serif" size="2">及&nbsp;</font></span></p><p><span style="color:rgb(0,0,0)"><font face="simsun, serif" size="2"><a href="http://gnuradio.org/redmine/repositories/entry/gnuradio/usrp/host/lib/fusb_linux.cc" rel="nofollow">source:usrp/host/lib/fusb_linux.cc</a>&nbsp;</font></span></p></blockquote></li></ul>
<ul><li> <font face="simsun, serif" size="2"><b>如果 USRP 仅存少量的数据（比如，数量远不足 fusb_nblock*fusb_block_size)，它是否仍旧会被 USRP 传输到计算机?</b>
</font><p><font face="simsun, serif" size="2">是的。USRP 以 USB 所规约的 512 byte 进行数据打包然后将其尽快传送出去。或者说 128 （byte）复合采样（</font><span style="font-family:simsun,serif;font-size:small">16-bit I &amp; Q</span><span style="font-family:simsun,serif;font-size:small">）数据。</span></p></li></ul>
<ul><li> <font face="simsun, serif" size="2"><b>什么是 USRP 针对 USB 同宿主计算机传输数据时所需的最小数据格式？它是 fusb_block_size 吗?</b>
</font><p><font face="simsun, serif" size="2">其大小是 512 bytes。它是基于 FX2 固件对其进行配置。</font></p></li></ul>
<ul><li> <font face="simsun, serif" size="2"><b>Looking through the FX2 data sheet, the GPIF  designer 
app's generated code and your edit_gpif  script output, I (hope) I have 
an understanding of the  actual data flow bus cycle (I am only focusing 
on  FIFORd):  You use flow states. There is a flowstate in state S1, 
which constantly asserts REN and OE (and BOGUS) while the transaction 
has not yet expired. It de-asserts all CTLx signals when the transfer is
 complete. USRP do data transfers on both edges of IFCLK. The FLOWSTB 
register indicates that CTL4 is your master strobe. I thought CTL4 was a
 reset signal (CLRST). To summarize: OE and REN are active-high, and 
data is clocked out on both edges of IFCLK. Is this correct?</b>
</font><p><font face="simsun, serif" size="2">是，</font></p><p><font face="simsun, serif" size="2">Yes, modulo problem with signals being asserted one cycle too long 
on WR.</font></p></li></ul>
<ul><li> <font face="simsun, serif" size="2"><b><b>RDYx 的那些管脚的随状态机有影响？ -&nbsp;</b>What part do the RDYx pins play in the flowstate?</b>
</font><p><font face="simsun, serif" size="2">没有。</font></p></li></ul>
<ul><li> <font face="simsun, serif" size="2"><b>它们（这些管脚 -&nbsp;
<b>RDYx pins</b>）仅影响&nbsp;
<b>S1, S2..S6</b>&nbsp;状态的转化吗？ -&nbsp;Do they only affect transitions between S1, S2..S6?</b>
</font><p><font face="simsun, serif" size="2">没，对此也无影响。</font></p></li></ul><font face="simsun, serif" size="2"><br>
</font><p style="text-align:right"><font face="simsun, serif" size="2"><b>[ <a href="usrpfaqlatency.html">&lt;&lt; 时延</a> 
| <a href="usrpfaq.html">^ USRP FAQ 首页 ^</a> ]</b><br></font></p><p><font face="simsun, serif" size="2"><br></font></p><p><font face="simsun, serif" size="2"><b><br>注：</b><b><a href="http://gnuradio.org/redmine/projects/gnuradio/wiki/UsrpFAQFX2" target="_blank" rel="nofollow">USB Controller FX2 Questions</a>（原文出处，翻译整理仅供参考!）</b></font></p></div></div></td></tr></tbody></table>
</div> 
</div> 
<div id="sites-canvas-bottom-panel">
<div id="sites-attachments-container">
</div>
</div>
</div> 
</td> 
<td id="sites-chrome-sidebar-right" class="sites-layout-sidebar-right initial" style="width:190px">
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_9153814178763965" class="sites-embed" role="navigation"><h4 class="sites-embed-title"> GNURadio 中文社区</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://gnuradio.microembedded.com/" class="sites-navigation-link">GNURadio：中文维客</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="http://gnuradio.microembedded.com/pageindex" class="sites-navigation-link">标题索引：GNURadio</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_3158427237433027" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="/a/microembedded.com/gnuradio/installinggr" jotid="wuid:gx:19c4ea49ca981168" class="sites-navigation-link">GNURadio: 安装指导</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/a/microembedded.com/gnuradio/faq" jotid="wuid:gx:59d38b2d5aff0b87" class="sites-navigation-link">GNURadio: 常见问题</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/a/microembedded.com/gnuradio/tutorials" jotid="wuid:gx:c2443ff1f7a56ec" class="sites-navigation-link">GNURadio: 讲义教程</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="/a/microembedded.com/gnuradio/development" jotid="wuid:gx:447c739ef5066bd4" class="sites-navigation-link">GNURadio: 社区贡献</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_6502772558432737" class="sites-embed" role="navigation"><h4 class="sites-embed-title"> GNURadio 最新发布</h4><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="https://sites.google.com/a/microembedded.com/gnuradio/news#TOC-GNU-Radio:-GNU-Radio-release-3.6.3-available-for-download" class="sites-navigation-link">GNURadio 3.6.3</a></div></li><li class=""><div dir="ltr" style="padding-left: 5px;"><a href="https://sites.google.com/a/microembedded.com/gnuradio/news#TOC-GNU-Radio:-GNU-Radio-release-candidate-3.6.3rc0-available-for-download" class="sites-navigation-link">GNURadio 3.6.3rc0</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_4277110048101279" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://gnuradio.microembedded.com/openbts" class="sites-navigation-link">GNURadio - OpenBTS 中文维客 </a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_41189823539683246" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://openbts.microembedded.com/" class="sites-navigation-link">（Range）- OpenBTS 中文社区</a></div></li></ul></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_43043355133298733" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"></div></div>
<div xmlns="http://www.w3.org/1999/xhtml" id="COMP_6312697504782834" class="sites-embed" role="navigation"><div class="sites-embed-content sites-sidebar-nav"><ul role="navigation" jotid="navList"><li class="nav-first "><div dir="ltr" style="padding-left: 5px;"><a href="http://ossie.microembedded.com/" class="sites-navigation-link">SCA - OSSIE 中文维客</a></div></li></ul></div></div>
</td>
</tr>
</tbody></table>
                    <!-- InstanceEndEditable -->
                    </div>
                </div>
                <div id="sites-chrome-footer-wrapper">
                    <div id="sites-chrome-footer-wrapper-inside">
                        <div id="sites-chrome-footer">
                            <div xmlns="http://www.w3.org/1999/xhtml" class="sites-subfooter">
                                <div class="sites-subfooter-content">
                                    <div dir="ltr">
                                        <div style="text-align:center;font-family:simsun,serif">
                                            <div style="overflow:auto"> <font size="2"><span style="border-collapse:separate;color:rgb(0,0,0);font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px"><span style="text-align:center"><span style="border-collapse:separate;color:rgb(0,0,0);font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px"><span style="border-collapse:collapse">"This is an unofficial translation of the Gnu Radio project homepage.  Please use<span> </span><a href="http://gnuradio.org/">http://gnuradio.org/</a><span> </span> in case of any doubt." 此乃 GNU Radio 非官方中文翻译，如有疑问请参阅<span> </span></span></span><a href="http://gnuradio.org">http://gnuradio.org</a>。<br>
                                                <span style="border-collapse:separate;color:rgb(0,0,0);font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:normal;text-indent:0px;text-transform:none;white-space:normal;word-spacing:0px"><span style="border-collapse:collapse">Chinese translation provided by<br>
                                                <span> </span>
                                                <a href="http://www.microembedded.com/" target="_blank">Microembedded Electronic (Beijing) Co. Ltd.</a><span> </span></span></span><a href="http://www.microembedded.com/" target="_blank">微嵌电子技术（北京）有限责任公司</a>
                                                <span> </span>提供翻译</span></span></font><br><br>
                                                <font>©2009 MicroEmbedded 备案信息：京ICP备15049573号 京公网安备：110108904713</font>
                                                </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="sites-chrome-onebar-footer"> </div>
</body>
<!-- InstanceEnd --></html>